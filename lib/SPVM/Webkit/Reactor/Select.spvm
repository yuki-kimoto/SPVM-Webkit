class Webkit::Reactor::Select {
  use Webkit::Callback;
  use Webkit::Timer;
  use Time;

  has running : byte;
  has timers : HASH;
  
  method is_running : int { return $self->{running}; }
  
  method recurring : void ($after : int, $cb : Webkit::Callback) : void { return $self->_timer(1, $after, $cb); }

  method timer : void ($after : int, $cb : Webkit::Callback) { return $self->_timer(0, $after, $cb); }

  method _timer : void ($recurring : int, $after : int, $cb : Webkit::Callback) {
    my $id = $self->_id;
    my $timer = Webkit::Timer->new;
    $timer->set_cb($cb);
    $timer->set_after($after);
    $timer->set_recurring($recurring);
    $timer->set_time(Time->time + $after);
    $self->{timers}->set($id => $timer);
    
    return $id;
  }

  method _id : int () {
    my $id = 0;
    while (1) {
      $id = "t" . Time->time . rand($SEED);
      if ($self->{timers}->get($id)) {
        next;
      }
      else {
        last;
      }
    }
    
    return $id;
  }

  method start : void {
    $self->{running} = 1;
    while ($self->{running}) {
      $self->one_tick;
    }
  }

  method stop : void { $self->{running} = 0; }

  method one_tick {
    my $self = shift;

    # Just one tick
    local $self->{running} = 1 unless $self->{running};

    # Wait for one event
    my $i;
    until ($i || !$self->{running}) {

      # Stop automatically if there is nothing to watch
      return $self->stop unless keys %{$self->{timers}} || keys %{$self->{io}};

      # Calculate ideal timeout based on timers and round up to next millisecond
      my $min     = min map { $_->{time} } values %{$self->{timers}};
      my $timeout = defined $min ? $min - steady_time : 0.5;
      $timeout = $timeout <= 0 ? 0 : int($timeout * 1000) + 1;

      # I/O
      if (keys %{$self->{io}}) {
        my @poll = map { $_ => $self->{io}{$_}{mode} } keys %{$self->{io}};

        # This may break in the future, but is worth it for performance
        if (IO::Poll::_poll($timeout, @poll) > 0) {
          while (my ($fd, $mode) = splice @poll, 0, 2) {

            if ($mode & (POLLIN | POLLPRI | POLLNVAL | POLLHUP | POLLERR)) {
              next unless my $io = $self->{io}{$fd};
              ++$i and $self->_try('I/O watcher', $io->{cb}, 0);
            }
            next unless $mode & POLLOUT && (my $io = $self->{io}{$fd});
            ++$i and $self->_try('I/O watcher', $io->{cb}, 1);
          }
        }
      }

      # Wait for timeout if poll can't be used
      elsif ($timeout) { usleep($timeout * 1000) }

      # Timers (time should not change in between timers)
      my $now = steady_time;
      for my $id (keys %{$self->{timers}}) {
        next unless my $t = $self->{timers}{$id};
        next unless $t->{time} <= $now;

        # Recurring timer
        if ($t->{recurring}) { $t->{time} = $now + $t->{after} }

        # Normal timer
        else { $self->remove($id) }

        ++$i and $self->_try('Timer', $t->{cb}) if $t->{cb};
      }
    }
  }

  method _try : void ($what : string, $cb : Webkit::Callback, $args : object[]...) {
    eval { $cb->($self, $args)); };
    
    if ($@) {
      $self->emit(error => "$what failed: $@");
    }
  }
  
  method remove_timer : int ($id : int) {
    return $self->{timers}->delete($id);
  }
  
=pod

  method one_tick {
    my $self = shift;

    # Just one tick
    local $self->{running} = 1 unless $self->{running};

    # Wait for one event
    my $i;
    until ($i || !$self->{running}) {

      # Stop automatically if there is nothing to watch
      return $self->stop unless keys %{$self->{timers}} || keys %{$self->{io}};

      # Calculate ideal timeout based on timers and round up to next millisecond
      my $min     = min map { $_->{time} } values %{$self->{timers}};
      my $timeout = defined $min ? $min - steady_time : 0.5;
      $timeout = $timeout <= 0 ? 0 : int($timeout * 1000) + 1;

      # I/O
      if (keys %{$self->{io}}) {
        my @poll = map { $_ => $self->{io}{$_}{mode} } keys %{$self->{io}};

        # This may break in the future, but is worth it for performance
        if (IO::Poll::_poll($timeout, @poll) > 0) {
          while (my ($fd, $mode) = splice @poll, 0, 2) {

            if ($mode & (POLLIN | POLLPRI | POLLNVAL | POLLHUP | POLLERR)) {
              next unless my $io = $self->{io}{$fd};
              ++$i and $self->_try('I/O watcher', $io->{cb}, 0);
            }
            next unless $mode & POLLOUT && (my $io = $self->{io}{$fd});
            ++$i and $self->_try('I/O watcher', $io->{cb}, 1);
          }
        }
      }

      # Wait for timeout if poll can't be used
      elsif ($timeout) { usleep($timeout * 1000) }

      # Timers (time should not change in between timers)
      my $now = steady_time;
      for my $id (keys %{$self->{timers}}) {
        next unless my $t = $self->{timers}{$id};
        next unless $t->{time} <= $now;

        # Recurring timer
        if ($t->{recurring}) { $t->{time} = $now + $t->{after} }

        # Normal timer
        else { $self->remove($id) }

        ++$i and $self->_try('Timer', $t->{cb}) if $t->{cb};
      }
    }
  }

  method reset { delete @{shift()}{qw(events io next_tick next_timer running timers)} }

=cut

}
